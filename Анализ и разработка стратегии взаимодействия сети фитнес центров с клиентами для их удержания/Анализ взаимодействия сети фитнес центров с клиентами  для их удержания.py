#!/usr/bin/env python
# coding: utf-8

# # Анализ и разработка стратегии взаимодействия сети фитнес центров с клиентами  для их удержания.

# **Заказчик** —  Сеть фитнес-центров «Культурист-датасаентист».
# 
# **Цель:** Провести анализ и подготовить план действий по удержанию клиентов, а именно:<br/>
# •	сделать прогноз вероятности оттока (на уровне следующего месяца) для каждого клиента;<br/>
# •	сформировать типичные портреты клиентов: выделить несколько наиболее ярких групп и охарактеризовать их основные свойства;<br/>
# •	проанализировать основные признаки, наиболее сильно влияющие на отток;<br/>
# •	сформулировать основные выводы и разработать рекомендации по повышению качества работы с клиентами:<br/> 
# o	1) выделить целевые группы клиентов;<br/>
# o	2) предложить меры по снижению оттока;<br/>
# o	3) определить другие особенности взаимодействия с клиентами.<br/>
# 
# 
# **Входные данные:** Сведения от Заказчика в csv-файлах /datasets/gym_churn.csv., которые содержат данные на месяц до оттока и факт оттока на определённый месяц.
# 
# **Описание данных:**
# 
# * Данные клиента за предыдущий до проверки факта оттока месяц: <br/>
# o	`gender` — пол;<br/>
# o	`Near_Location` — проживание или работа в районе, где находится фитнес-центр;<br/>
# o	`Partner` — сотрудник компании-партнёра клуба (сотрудничество с компаниями, чьи сотрудники могут получать скидки на абонемент — в таком случае фитнес-центр хранит информацию о работодателе клиента);<br/>
# o	`Promo_friends` — факт первоначальной записи в рамках акции «приведи друга» (использовал промо-код от знакомого при оплате первого абонемента);<br/>
# o	`Phone` — наличие контактного телефона;<br/>
# o	`Age` — возраст;<br/>
# o	`Lifetime` — время с момента первого обращения в фитнес-центр (в месяцах).<br/>
# 
# * Информация на основе журнала посещений, покупок и информация о текущем статусе абонемента клиента:<br/>
# o	`Contract_period` — длительность текущего действующего абонемента (месяц, 6 месяцев, год);<br/>
# o	`Month_to_end_contract` — срок до окончания текущего действующего абонемента (в месяцах);<br/>
# o	`Group_visits` — факт посещения групповых занятий;<br/>
# o	`Avg_class_frequency_total` — средняя частота посещений в неделю за все время с начала действия абонемента;<br/>
# o	`Avg_class_frequency_current_month` — средняя частота посещений в неделю за предыдущий месяц;<br/>
# o	`Avg_additional_charges_total` — суммарная выручка от других услуг фитнес-центра: кафе, спорттовары, косметический и массажный салон.<br/>
# o	`Churn` — факт оттока в текущем месяце.
# 

# <a id="enter"></a>
# **Содержание:**
# 
# 1. [Исследовательский анализ данных (EDA).](#eda)
#     * [1.1 Предобработка данных](#fist)
#     * [1.2 Определение степени влияния признаков на целевой параметр](#ind)
# 2. [Построение моделей прогнозирования оттока клиентов](#mod)
# 3. [Кластеризация клиентов](#klust)
# 4. [Выводы](#conclusion)

# **Библиотеки, используемые в проекте**

# In[1]:


import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import itertools
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score
from sklearn.cluster import KMeans
from scipy.cluster.hierarchy import dendrogram, linkage 


# **Функции, используемые в проекте**

# In[2]:


# функция отрисовки гистограмм признаков 
def attr_hist(df, x_name, cluster_name):
    plt.figure(figsize=(5, 5))
    sns.histplot(df,
        x=x_name, hue=cluster_name)
    plt.title('{}'.format(x_name))
    plt.show()


# In[3]:


# функция расчета метрик прогнозирования оттока 
def make_prediction(m, X_train, y_train, X_test, y_test):
    model = m
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    print('Accuracy:{:.2f}, Precision: {:.2f}, Recall: {:.2f}'.format(accuracy_score(y_test, y_pred),
    precision_score(y_test, y_pred),
    recall_score(y_test, y_pred)
))


# In[4]:


# функция отрисовки графиков попарных признаков для кластеров
def show_clusters_on_plot(df, x_name, y_name, cluster_name):
    plt.figure(figsize=(5, 5))
    sns.scatterplot(
        df[x_name], df[y_name], hue=df[cluster_name], palette='Paired'
    )
    plt.title('{} vs {}'.format(x_name, y_name))
    plt.show()


# <a id='eda'></a>
# ## Исследовательский анализ данных (EDA)

# <a id='first'></a>
# ### Предобработка данных

# Прочтем данные и выведем информацию об их содержимом.

# In[5]:


df = pd.read_csv('/datasets/gym_churn.csv')


# In[6]:


df.info()


# Исходная таблица состоит из 4000 строк и 14 столбцов, не содержащих пропусков и имеющих тип `int64` и `float64`. Далее рассмотрим описание данных.

# In[7]:


df.describe()


# Из описания видно, что в целом по полу распределение клиентов одинаковое, число тех кто проживает или работает вблизи заметно больше (85%) и около половины пришли по промокоду. Основная масса посетителей оставляет номер телефона. Средняя длительность абонемента 4,7 месяца, что почти равно стандартному отклонению и говорит о большом разбросе значений. Меньше половины в среднем  (41%) посещает групповые занятия. Стандартное отклонение относительно среднего возраста (29 лет) небольшое - 3 года и характеризует возраст основной массы. Дополнительные расходы имеют заметный разброс (96 р) относительно среднего 147 р. Столбец срок до конца абонемента имеет разброс близкий к среднему значению 4,3. Общий период посещений в среднем составляет около 4 месяцев при том же стандартном отклонении (кто-то приобрел абонемент, но так и не смог добраться до спортзала, а кто-то посещает больше двух лет, но менее трех). Средняя частота посещений - 2 раза в неделю. Там где 0 неизвестно как оценивать, нужно проверить сколько таких. В последнем столбце значения целевой переменной где обозначены выбывшие и оставшиеся клиенты. Видно что выбывших заметно меньше (26,5%).<br/> Посмотрим как различаются средние значения признаков среди посещающих и выбывших.

# [к Содержанию](#enter)

# Проверка на дубликаты:

# In[8]:


df.duplicated().unique()


# Дубликатов нет

# In[9]:


df['Month_to_end_contract'].head()


# Столбец со сроком до конца абонемента содержит целые числа, а имеет тип float64. Исправим:

# In[10]:


df['Month_to_end_contract'] = df['Month_to_end_contract'].astype('int')
df['Month_to_end_contract'].dtype


# <a id='ind'></a>
# ### Определение степени влияния признаков на целевой параметр

# In[11]:


print(df.groupby('Churn').mean().T)


# In[12]:


print('Число убывших и посещающих клиентов:', df.groupby('Churn')['Churn'].count())


# Цифры говорят, что у этого клуба число убывших клиентов почти в 3 раза ниже посещающих.

# Средние значения признаков двух групп почти не отличаются по половому признаку. Среди тех кто выбыл близкоживущих/работающих меньше.Также среди отскочивших больше тех, кто не имеет скидки на абонемент или пришел по промокоду. И среди бросивших и среди посетителей одинаковая доля оставивших номер телефона. Срок абонемента у большинства прекративших заниматься 1 месяц, тогда как у посещающих - 6 месяцев. Среди бросивших доля посетителей групповых занятий на 20% ниже. Средний возраст ушедших из клуба на 3 года меньше. Средняя сумма дополнительных расходов у текущих клиентов выше чем у бывших. Средний срок до конца абонемента у занимающихся заметно выше (5,3 по сравнению с 1,7). Продолжительность сотрудничества у забросивших занятия 1 месяц, а у занимающихся 4,7 месяца. Частота посещений в неделю в текущем месяце близко к прошлому при этом у бросивших ниже чем у занимающихся.

# In[13]:


for i in df.drop('Churn', axis=1).columns:
    attr_hist(df, i, 'Churn')


# По 5 первым признакам и "групповым занятиям" графики отразили вышесказанное. Что касается других признаков, то сроки действия абонемента заметно влияют на отток, чем меньше срок тем больше отток, что объяснимо. По возрастам распределение имеет нормальный характер, со смещенными максимумами (как уже говорилось у клиентов это 29 лет, у бывших - 27). График дополнительных расходов имеет правостороннее распределение из-за того что многие не имеют дополнительных расходов. Среди количества месяцев до конца абонемента в обеих группах максимум на 1 месяце, на 6 месяцах гораздо меньше и далее ещё меньше.

# In[14]:


#построим и отрисуем матрицу корреляций
cm = df.corr() 
#нарисуем тепловую карту с подписями для матрицы корреляций
fig, ax = plt.subplots(figsize=(20, 15))
sns.heatmap(cm, annot=True, square=True)
plt.show()


# На тепловой карте кореляций можно видеть что целевая переменная мало с чем из признаков коррелирует. Можно отметить, что слабая обратная зависимость есть со сроком абонемента, с возрастом, временем до конца абонемента и частотой посещений в текущем месяце. Интересно также отметить, что в предыдущем месяце зависимость от частоты посещений была вдвое больше. Что-то изменилось, причем так что больше признаков стали влиять в минус на отскок. Ещё одна странность не смотря на высокую корреляцию частот посещений в предыдущий и текущий месяц между собой, они по-разному влияют на отскок. Сильная взаимная корреляция наблюдается между сроком абонемента и числом месяцев до его окончания.

# Поскольку есть взаимно коррелирующие признаки и данные не влияющие на целевую переменную, считаю уместным их удалить для снижения негативного влияния на дальнейшее исследование. Кроме того, думаю было бы неправильно оставлять строки для тех посетителей которые не ходили вовсе.

# In[15]:


df=df.drop(['Month_to_end_contract', 'Avg_class_frequency_current_month', 'gender', 'Phone'], axis=1)


# In[16]:


df[df['Avg_class_frequency_total']==0]['Avg_class_frequency_total'].count()


# In[17]:


df=df[df['Avg_class_frequency_total']!=0]


# **Промежуточные выводы:**
# 1. Исходный датасет состоит из 4000 строк и 14 столбцов, не содержащих пропусков.
# 2. Аномалий не обнаружено, но есть эксремальные значения искажающие средние величины (нулевая частота посещений, и частота превышающая 6 дней в неделю, годовые абонементы, дополнительные расходы свыше 550 р, лайфтайм 31 месяц.
# 3. Среднестатистический посетитель: 29 лет со сроком абонемента 1 месяц, тратящий 147 р дополнительно, с частотой посещений - 2 раза в неделю.
# 3. Признаки наиболее влияющие на целевую переменную: Cрок абонемента, возраст, время до конца абонемента и частота посещений в текущем месяце.

# [к Содержанию](#enter)

# <a id='mod'></a>
# ## Построение моделей прогнозирования оттока клиентов

# По условиям сформулированной задачи можно сказать, что она является типичным примером задач бинарной классификации с учителем.
# Для её решения подходят следующие алгоритмы: Логистическая регрессия, дерево принятия решений, случайный лес и градиентный бустинг. В данном проекте применим первый и третий (`Логистическая регрессия` и `Cлучайный лес`), а также проведем их оценку метриками:<br/>
# * `Accuracy`, которая оценивает долю верных ответов среди всех ((TP+TN)/n), но дает погрешность если объекты соотносятся примерно поровну (в нашем случае это не так ведь целевые значения разделяются 25:75);
# * `Precision` показывает какая доля прогнозов относительно 1 верна по сравнению с числом прогнозов 1 (TP/(TP+FP));
# * `Recall` показывает сколько верных 1 по отношению ко всем 1 в итоге (TP/(TP+FN))

# In[25]:


df = df.copy()


# In[26]:


X = df.drop('Churn', axis = 1)
y = df['Churn']

# разделим модель на обучающую и валидационную выборку
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)

# зададим обучим модель стандартизации признаков
scaler = StandardScaler()
scaler.fit(X_train)

# Преобразем обучающий и валидационные наборы данных
X_train_st = scaler.transform(X_train)
X_test_st = scaler.transform(X_test)
# зададим список моделей
models = [
    LogisticRegression(solver='liblinear', random_state=0),
    RandomForestClassifier(random_state=0)
]

# напишем цикл, который выводит метрики по списку моделей
for i in models:
    print(i)
    make_prediction(i, X_train_st, y_train, X_test_st, y_test)


# Итак, метрики показывают, что обе модели подходят для прогнозов (все показатели приближаются к 1), а на модели LogisticRegression Recall выше.

# **Промежуточные выводы:**
# 1. Алгоритмы обучения (Логистическая регрессия и Случайный лес) с помощью метрик Accuracy, Precision и Recall показали приемлемую точность на валидационной выборке.
# 2. В соответствии с метрикой Recall алгоритм логистической регрессии оказался немного точнее.

# [к Содержанию](#enter)

# <a id='klust'></a>
# ## Кластеризация клиентов

# Разделим клиентов на 5 кластеров чтобы оценить какой из кластеров оказывает наибольшее влияние на отток клиентов.

# In[28]:


# стандартизация данных перед работой с алгоритмами
sc = StandardScaler()
X_sc = sc.fit_transform(X)

linked = linkage(X_sc, method = 'ward')
plt.figure(figsize=(25, 10))  
dendrogram(linked, orientation='top')
plt.title('Hierarchial clustering for GYM')
plt.show() 


# In[29]:


# задаём модель k_means с числом кластеров 5 и фиксируем значение random_state
km = KMeans(n_clusters=5, random_state=0)
# прогнозируем кластеры для наблюдений 
labels = km.fit_predict(X_sc)

# сохраняем метки кластера в поле нашего датасета
X['cluster_km'] = labels

# выводим статистику по средним значениям наших признаков по кластеру

print(X.groupby('cluster_km').mean())

# отрисуем графики для попарных сочетаний признаков с разметкой по кластерам
col_pairs = list(itertools.combinations(X.drop('cluster_km', axis=1).columns, 2))
for pair in col_pairs:
    show_clusters_on_plot(X, pair[0], pair[1], 'cluster_km')


# Как видно выраженных границ между кластерами нет, много пересечений. Так, клиенты по возрасту почти равномерно распределены между кластерами. Нулевой кластер выделяется самым больши сроком абонемента, с самыми высокими дополнительными расходами, сроком абонемента и частотой посещений. В первом кластере любители групповых занятий, живущие рядом и не имеющие скидку и без промокода. Клиенты второго кластера далеко живут, не имеют промокода и изредка посещают групповые занятия. В 3 кластере - живущие/работающие по соседству, имеют скидку и промокод, а также долгий абонемент. В 4 кластере - не ходят на групповые занятия, живут рядом, без скидки и промокода и с коротким абонементом и низким лайфтаймом.

# Посчитаем долю оттока для каждого кластера.

# In[21]:


X['Churn'] = df['Churn']

X[X['Churn']==1][['cluster_km', 'Churn']].groupby('cluster_km').count()/(X[X['Churn']==1]['Churn'].count())


# Итак, наибольший отток наблюдается в 4 кластере, где не ходят на групповые занятия, живут рядом, без скидки и промокода и с коротким абонементом и низким лайфтаймом. Наименьший - в кластере 0 большим сроком абонемента, с самыми высокими дополнительными расходами, и частотой посещений. Группа с большим оттоком отличается от остальных непосещением групповых занятий и маленьким сроком абонемента. Остальные кластеры между собой различаются по наличию и отсутствию скидок, сроком абонемента, местом проживания.

# **Промежуточные выводы:**
# 1. Самые стойкие клиенты имеют большой срок абонемента, дополнительные расходы и частоту посещений.
# 2. Группа с наибольшим оттоком -4, с низким сроком абонемента, не посещающая групповые занятия, без скидки и промокода.

# <a id='conclusion'></a>
# ## Выводы

# 1. Исходный датасет состоит из 4000 строк и 14 столбцов, не содержащих пропусков.
# 2. Аномалий не обнаружено, но есть эксремальные значения искажающие средние величины (нулевая частота посещений, и частота превышающая 6 дней в неделю, годовые абонементы, дополнительные расходы свыше 550 р, лайфтайм 31 месяц.
# 3. Среднестатистический посетитель: 29 лет со сроком абонемента 1 месяц, тратящий 147 р дополнительно, с частотой посещений - 2 раза в неделю.
# 4. Признаки наиболее влияющие на целевую переменную: Cрок абонемента, возраст, время до конца абонемента и частота посещений в текущем месяце.
# 5. Алгоритмы обучения (Логистическая регрессия и Случайный лес) с помощью метрик Accuracy, Precision и Recall показали приемлемую точность на валидационной выборке.
# 6. В соответствии с метрикой Recall алгоритм логистической регрессии оказался немного точнее.
# 7. Группа с наибольшим оттоком -4, с низким сроком абонемента, не посещающая групповые занятия, без скидки и промокода.
# 8. Целевая аудитория - корпоративные клиенты, посещающие групповые занятия, пользующиеся дополнительными услугами и часто приходящие по промокоду.
# 9. Чтобы снизить оттток необходимо среди близлежайших предприятий устраивать рекламные акции в виде бесплатных занятий и лекций.
# 10. Кроме того, на территориях клуба вводить дни открытых дверей, розыгрыши абонементов, мастер-классы. В ближайших супермаркетах и ресторанах распространять рекламные листовки, активно продвигать услуги через интернет.

# [к Содержанию](#enter)
